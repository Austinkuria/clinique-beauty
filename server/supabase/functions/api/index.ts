import { serve } from 'https://deno.land/std@0.177.0/http/server.ts';
import { createClient, SupabaseClient, User } from 'https://esm.sh/@supabase/supabase-js@2';
import { corsHeaders } from '../_shared/cors.ts'; // Import from the new shared file

// Remove allowedOrigins definition from here
// const allowedOrigins = [ ... ];

// Helper to get user from JWT
async function getUser(supabaseClient: SupabaseClient): Promise<User | null> {
    console.log('[getUser] Attempting to get user from Supabase client...'); // Log entry
    try {
        const { data: { user }, error } = await supabaseClient.auth.getUser();
        if (error) {
            // Log the specific error from Supabase auth
            console.error('[getUser] Error from supabaseClient.auth.getUser():', error.message);
            return null;
        }
        if (!user) {
            console.log('[getUser] supabaseClient.auth.getUser() returned null user.'); // Log if no user found
        } else {
            console.log('[getUser] Successfully retrieved user:', user.id); // Log success
        }
        return user;
    } catch (catchError) {
        // Catch any unexpected errors during the process
        console.error('[getUser] Unexpected error:', catchError);
        return null;
    }
}

// Function to create Supabase client
const getSupabaseClient = (req: Request): SupabaseClient => {
    const authHeader = req.headers.get('Authorization');

    // Log whether the Authorization header was found
    if (authHeader) {
        console.log('[getSupabaseClient] Authorization header found.');
        // Avoid logging the full token for security, maybe just the type 'Bearer'
        // console.log('[getSupabaseClient] Auth Header Type:', authHeader.split(' ')[0]);
        return createClient(
            Deno.env.get('PROJECT_SUPABASE_URL') ?? '',
            Deno.env.get('PROJECT_SUPABASE_ANON_KEY') ?? '',
            { global: { headers: { Authorization: authHeader } } } // Pass the received token
        );
    } else {
        console.log('[getSupabaseClient] No Authorization header found. Creating client with ANON KEY.');
        // Create client using the ANON KEY (for public routes like getting products)
        return createClient(
            Deno.env.get('PROJECT_SUPABASE_URL') ?? '',
            Deno.env.get('PROJECT_SUPABASE_ANON_KEY') ?? ''
        );
    }
};

serve(async (req: Request) => {
    const url = new URL(req.url);
    const pathSegments = url.pathname.split('/').filter(Boolean);
    const apiPathIndex = pathSegments.findIndex(segment => segment === 'api');

    // --- Add Detailed Routing Logs ---
    console.log(`[Router] Incoming URL: ${req.url}`);
    console.log(`[Router] Pathname: ${url.pathname}`);
    console.log(`[Router] Path Segments: ${JSON.stringify(pathSegments)}`);
    console.log(`[Router] API Path Index: ${apiPathIndex}`);
    // --- End Detailed Routing Logs ---

    // If 'api' is not found, or it's the last segment, the route is effectively empty or invalid
    if (apiPathIndex === -1) { // Simplified check: if 'api' isn't found at all
        console.warn(`[Router] 'api' segment not found in path: ${url.pathname}`);
        // Return 404 early if '/api/' structure is expected but missing
        const headers = new Headers({
            'Content-Type': 'application/json',
            ...corsHeaders(req.headers.get('Origin')) // Add CORS headers
        });
        return new Response(JSON.stringify({ message: "Base path '/api' not found in URL" }), { headers, status: 404 });
    }

    // Slice the array *after* the 'api' segment to get the actual route parts
    const route = pathSegments.slice(apiPathIndex + 1);
    // Example: if path is /functions/v1/api/cart/add, route should be ['cart', 'add']
    // Example: if path is /functions/v1/api, route should be []

    // --- Add Detailed Routing Logs ---
    console.log(`[Router] Calculated Route: ${JSON.stringify(route)}`);
    // --- End Detailed Routing Logs ---

    const origin = req.headers.get('Origin');
    // isAllowedOrigin check is implicitly handled by corsHeaders function now

    // --- CORS Preflight Request Handling ---
    if (req.method === 'OPTIONS') {
        // Let corsHeaders handle origin checking logic implicitly if needed,
        // or explicitly check if required by your logic before returning headers.
        // For simplicity, we return the headers generated by corsHeaders.
        return new Response('ok', { headers: corsHeaders(origin) });
    }

    // --- Prepare Response Headers ---
    const headers = new Headers({
        'Content-Type': 'application/json',
        ...corsHeaders(origin) // Add CORS headers generated by the shared function
    });

    // --- API Routing ---
    try {
        console.log(`[Request Start] ${req.method} ${req.url}`); // Log incoming request
        const supabase = getSupabaseClient(req); // Get client (potentially authenticated)

        // --- Public Product Routes ---
        // GET /api/products
        if (req.method === 'GET' && route[0] === 'products' && route.length === 1) {
            console.log('[Route Handler] Matched GET /api/products'); // Log route match
            const category = url.searchParams.get('category');
            const subcategory = url.searchParams.get('subcategory');
            let query = supabase.from('products').select('*');
            if (category) {
                console.log(`[Route Handler GET /api/products] Filtering by category: ${category}`);
                query = query.eq('category', category);
            }
            if (subcategory) {
                console.log(`[Route Handler GET /api/products] Filtering by subcategory: ${subcategory}`);
                query = query.eq('subcategory', subcategory);
            }

            console.log('[Route Handler GET /api/products] Executing query...');
            const { data, error } = await query;

            if (error) {
                console.error('[Route Handler GET /api/products] Error fetching products:', error);
                throw error;
            }

            // --- Add Logging Here ---
            console.log(`[Route Handler GET /api/products] Query successful. Data received:`, data);
            console.log(`[Route Handler GET /api/products] Returning ${data?.length ?? 0} products.`);
            // --- End Logging ---

            return new Response(JSON.stringify(data || []), { headers, status: 200 });
        }
        // GET /api/products/:id
        if (req.method === 'GET' && route[0] === 'products' && route.length === 2) {
            // ... existing product/:id fetching logic ...
            const id = route[1];
            const { data, error } = await supabase.from('products').select('*').eq('id', id).maybeSingle();
            if (error) throw error;
            if (!data) return new Response(JSON.stringify({ message: 'Product not found' }), { headers, status: 404 });
            return new Response(JSON.stringify(data), { headers, status: 200 });
        }

        // --- Authenticated Cart Routes ---
        // Check for Authorization header for protected routes
        const authHeader = req.headers.get('Authorization');
        if (!authHeader && route[0] === 'cart') { // Protect all /cart routes
             return new Response(JSON.stringify({ message: 'Authentication required' }), { headers, status: 401 });
        }

        // GET /api/cart
        if (req.method === 'GET' && route[0] === 'cart' && route.length === 1) {
            console.log('[Route Handler] Matched GET /api/cart'); // Log route match
            const user = await getUser(supabase);
            if (!user) {
                // Log the reason for 401
                console.log('[Route Handler GET /api/cart] No authenticated user found. Returning 401.');
                return new Response(JSON.stringify({ message: 'Unauthorized' }), { headers, status: 401 });
            }

            // Fetch cart items joined with product details for the user
            // Adjust table/column names ('cart_items', 'product_id', 'user_id', 'products(*)') as needed
            console.log(`[Route Handler GET /api/cart] User ${user.id} authenticated. Fetching cart items...`);
            const { data: cartItems, error } = await supabase
                .from('cart_items')
                .select(`
                    quantity,
                    product_id,
                    products (
                        id, name, price, image, description, category, subcategory, stock
                    )
                `)
                .eq('user_id', user.id);

            if (error) {
                 console.error(`[Route Handler GET /api/cart] Error fetching cart items for user ${user.id}:`, error);
                 throw error; // Let the main error handler catch it
            }
            console.log(`[Route Handler GET /api/cart] Successfully fetched cart items for user ${user.id}.`);

            // Format the response to match frontend expectations (flatten product details)
            const formattedCart = (cartItems || []).map(item => ({
                id: item.product_id, // Use product_id as the main ID for the cart item line
                quantity: item.quantity,
                ...(item.products || {}) // Spread product details
            }));

            return new Response(JSON.stringify(formattedCart || []), { headers, status: 200 });
        }

        // POST /api/cart/add
        if (req.method === 'POST' && route[0] === 'cart' && route[1] === 'add') {
            console.log('[Route Handler] Matched POST /api/cart/add'); // Log route match
            const user = await getUser(supabase);
            if (!user) {
                console.log('[Route Handler POST /api/cart/add] No authenticated user found. Returning 401.');
                return new Response(JSON.stringify({ message: 'Unauthorized' }), { headers, status: 401 });
            }
            console.log(`[Route Handler POST /api/cart/add] User ${user.id} authenticated.`);

            const { productId, quantity, shade } = await req.json(); // Assuming shade might be used later

            if (!productId || !quantity || quantity < 1) {
                return new Response(JSON.stringify({ message: 'Product ID and valid quantity required' }), { headers, status: 400 });
            }

            // --- Get Product Stock ---
            const { data: productData, error: productError } = await supabase
                .from('products')
                .select('stock')
                .eq('id', productId)
                .single();

            if (productError || !productData) {
                return new Response(JSON.stringify({ message: 'Product not found or stock information unavailable' }), { headers, status: 404 });
            }
            const availableStock = productData.stock;
            // --- End Get Product Stock ---


            // Check if item already exists in cart for this user
            const { data: existingItem, error: findError } = await supabase
                .from('cart_items')
                .select('id, quantity')
                .eq('user_id', user.id)
                .eq('product_id', productId)
                // Add .eq('shade_name', shade) if tracking shades in DB
                .maybeSingle();

            if (findError) throw findError;

            let updatedOrNewItemId: string | null = null;
            let operationStatus = 200; // Default to 200 OK for update

            if (existingItem) {
                // --- Update existing item ---
                const newQuantity = existingItem.quantity + quantity;

                // Check stock before updating
                if (newQuantity > availableStock) {
                    return new Response(JSON.stringify({ message: `Not enough stock. Only ${availableStock} available.` }), { headers, status: 400 });
                }

                const { data: updatedItem, error: updateError } = await supabase
                    .from('cart_items')
                    .update({ quantity: newQuantity, updated_at: new Date() })
                    .eq('id', existingItem.id)
                    .select('id') // Only need the ID
                    .single();

                if (updateError) throw updateError;
                updatedOrNewItemId = updatedItem.id;
                // operationStatus remains 200 OK

            } else {
                // --- Insert new item ---
                // Check stock before inserting
                if (quantity > availableStock) {
                    return new Response(JSON.stringify({ message: `Not enough stock. Only ${availableStock} available.` }), { headers, status: 400 });
                }

                const { data: newItem, error: insertError } = await supabase
                    .from('cart_items')
                    .insert({
                        user_id: user.id,
                        product_id: productId,
                        quantity: quantity,
                        // shade_name: shade // Add if tracking shades
                    })
                    .select('id') // Only need the ID
                    .single();

                if (insertError) throw insertError;
                updatedOrNewItemId = newItem.id;
                operationStatus = 201; // 201 Created for new item
            }

            if (!updatedOrNewItemId) {
                 throw new Error("Failed to get ID of updated/inserted cart item.");
            }

            // --- Refetch the item with product details to return ---
            const { data: finalItem, error: finalError } = await supabase
                .from('cart_items')
                .select(`
                    id,
                    quantity,
                    product_id,
                    products (
                        id, name, price, image, description, category, subcategory, stock
                    )
                `)
                .eq('id', updatedOrNewItemId) // Use the ID from the insert/update result
                .single();

            if (finalError) {
                console.error("Error fetching final cart item details after add/update:", finalError);
                // If refetch fails, return a simple success message with the ID
                return new Response(JSON.stringify({ id: updatedOrNewItemId, message: "Operation successful, but failed to fetch full details." }), { headers, status: operationStatus });
            }

            // Format the final response similar to GET /cart item structure expected by client's formatCartItem
            const formattedItem = {
                cartItemId: finalItem.id, // Keep the actual cart_items PK if needed
                id: finalItem.product_id, // Product ID (used as primary ID in client state)
                quantity: finalItem.quantity,
                ...(finalItem.products || {}) // Spread product details
            };

            return new Response(JSON.stringify(formattedItem), { headers, status: operationStatus });
        }

        // PUT /api/cart/update (or similar, e.g., /api/cart/item/:itemId)
        // Example using /api/cart/update with body { itemId, quantity }
        // Note: itemId here refers to the cart_items table primary key, NOT product_id
        if (req.method === 'PUT' && route[0] === 'cart' && route[1] === 'update') {
             console.log('[Route Handler] Matched PUT /api/cart/update'); // Log route match
             const user = await getUser(supabase);
             if (!user) {
                 console.log('[Route Handler PUT /api/cart/update] No authenticated user found. Returning 401.');
                 return new Response(JSON.stringify({ message: 'Unauthorized' }), { headers, status: 401 });
             }
             console.log(`[Route Handler PUT /api/cart/update] User ${user.id} authenticated.`);

             const { itemId, quantity } = await req.json();

             if (!itemId || quantity === undefined || quantity < 0) {
                 return new Response(JSON.stringify({ message: 'Cart Item ID and valid quantity required' }), { headers, status: 400 });
             }

             if (quantity === 0) {
                 // Handle removal if quantity is 0
                 const { error: deleteError } = await supabase
                     .from('cart_items')
                     .delete()
                     .eq('id', itemId)
                     .eq('user_id', user.id); // Ensure user owns the item

                 if (deleteError) throw deleteError;
                 return new Response(JSON.stringify({ message: 'Item removed' }), { headers, status: 200 });

             } else {
                 // Update quantity
                 const { data, error } = await supabase
                     .from('cart_items')
                     .update({ quantity: quantity })
                     .eq('id', itemId)
                     .eq('user_id', user.id) // Ensure user owns the item
                     .select()
                     .single();

                 if (error) {
                     if (error.code === 'PGRST116') { // PostgREST code for "No rows found"
                         return new Response(JSON.stringify({ message: 'Cart item not found or not owned by user' }), { headers, status: 404 });
                     }
                     throw error;
                 }
                 return new Response(JSON.stringify(data), { headers, status: 200 });
             }
        }

        // DELETE /api/cart/remove (or similar, e.g., /api/cart/item/:itemId)
        // Example using /api/cart/remove with body { itemId }
        if (req.method === 'DELETE' && route[0] === 'cart' && route[1] === 'remove') {
             console.log('[Route Handler] Matched DELETE /api/cart/remove'); // Log route match
             const user = await getUser(supabase);
             if (!user) {
                 console.log('[Route Handler DELETE /api/cart/remove] No authenticated user found. Returning 401.');
                 return new Response(JSON.stringify({ message: 'Unauthorized' }), { headers, status: 401 });
             }
             console.log(`[Route Handler DELETE /api/cart/remove] User ${user.id} authenticated.`);

             const { itemId } = await req.json();

             if (!itemId) {
                 return new Response(JSON.stringify({ message: 'Cart Item ID required' }), { headers, status: 400 });
             }

             const { error } = await supabase
                 .from('cart_items')
                 .delete()
                 .eq('id', itemId)
                 .eq('user_id', user.id); // Ensure user owns the item

             if (error) throw error; // Could include check for not found if needed

             return new Response(JSON.stringify({ message: 'Item removed successfully' }), { headers, status: 200 });
        }

        // DELETE /api/cart/clear
        if (req.method === 'DELETE' && route[0] === 'cart' && route[1] === 'clear') {
             console.log('[Route Handler] Matched DELETE /api/cart/clear'); // Log route match
             const user = await getUser(supabase);
             if (!user) {
                 console.log('[Route Handler DELETE /api/cart/clear] No authenticated user found. Returning 401.');
                 return new Response(JSON.stringify({ message: 'Unauthorized' }), { headers, status: 401 });
             }
             console.log(`[Route Handler DELETE /api/cart/clear] User ${user.id} authenticated.`);

             const { error } = await supabase
                 .from('cart_items')
                 .delete()
                 .eq('user_id', user.id); // Delete all items for this user

             if (error) throw error;

             return new Response(JSON.stringify({ message: 'Cart cleared successfully' }), { headers, status: 200 });
        }

        // --- Fallback for unhandled routes ---
        console.warn(`[Route Handler] Route not found: ${req.method} ${url.pathname}`); // Add logging for 404s
        return new Response(JSON.stringify({ message: 'Route not found' }), { headers, status: 404 }); // Use headers

    } catch (error) {
        console.error('Error processing request:', error);
        // Use the headers object for error responses too
        return new Response(
            JSON.stringify({ message: error?.message || 'Internal Server Error' }),
            { headers: headers, status: 500 } // Use headers
        );
    }
});
